clear;
clc;

% Carga de datos 
load('comprimidas.mat', 'y_adpcm');
load('archivoproyectofinal.mat', 'Fs');

% Configuración OFDM
N_sub = 64;           % Número de subportadoras
cp_len = 16;          % Longitud del prefijo cíclico
bits_per_sample = 4;  % Bits por muestra (ADPCM)
mod_type = 'QPSK';    % Tipo de modulación

% Preparación de la señal 
% Asegurar que la señal tenga longitud múltiplo de N_sub
pad_samples = mod(length(y_adpcm), N_sub);
if pad_samples > 0
    y_adpcm = [y_adpcm; zeros(N_sub - pad_samples, 1)];
end

% Conversión a flujo de bits
% Escalamos y convertimos a valores enteros [0, 15]
y_scaled = round((y_adpcm + 1) * (2^(bits_per_sample-1) - 0.5));

% Preasignación y conversión directa a bits
bit_stream = zeros(1, length(y_scaled)*bits_per_sample);
for i = 1:bits_per_sample
    bit_stream(i:bits_per_sample:end) = bitget(y_scaled, bits_per_sample-i+1);
end

%  Modulación QPSK
% Creamos directamente los símbolos sin inicializar primero
bits_I = bit_stream(1:2:end);    % Bits en fase
bits_Q = bit_stream(2:2:end);    % Bits en cuadratura

% Mapeo QPSK (sin necesidad de zeros inicial)
symbols = (1-2*bits_I)/sqrt(2) + 1j*(1-2*bits_Q)/sqrt(2);

%  Configuración de transmisión OFDM 
num_symbols = length(symbols);
num_ofdm_blocks = ceil(num_symbols/N_sub);

% Preasignación completa del vector OFDM
ofdm_signal = zeros(1, num_ofdm_blocks*(N_sub + cp_len));

% Construcción de la señal OFDM 
for block_idx = 1:num_ofdm_blocks
    % Índices para los símbolos actuales
    start_idx = (block_idx-1)*N_sub + 1;
    end_idx = min(block_idx*N_sub, num_symbols);
    
    % Extraer símbolos para este bloque
    current_symbols = symbols(start_idx:end_idx);
    
    % Rellenar con ceros si es necesario
    if length(current_symbols) < N_sub
        current_symbols(N_sub) = 0; % Esto expande automáticamente el vector
    end
    
    % Transformada inversa y CP
    ifft_result = ifft(current_symbols, N_sub);
    ofdm_block = [ifft_result(end-cp_len+1:end), ifft_result];
    
    % Almacenar en la señal final
    block_start = (block_idx-1)*(N_sub + cp_len) + 1;
    block_end = block_idx*(N_sub + cp_len);
    ofdm_signal(block_start:block_end) = ofdm_block;
end

% Análisis de señal 
% PSD 
[psd, freq] = pwelch(ofdm_signal, hann(1024), 512, [], Fs);
psd_db = 10*log10(psd);

% PAPR cálculo
instant_power = abs(ofdm_signal).^2;
papr = 10*log10(max(instant_power)/mean(instant_power));

% Simulación de canal y BER 
ebno_range = 0:2:20;
ber_results = zeros(size(ebno_range));

for idx = 1:length(ebno_range)
    % Relación señal-ruido
    snr = ebno_range(idx) + 10*log10(2); % 2 bits/símbolo para QPSK
    
    % Canal AWGN
    noisy_signal = awgn(ofdm_signal, snr, 'measured');
    
    % Procesamiento en receptor
    rx_symbols = zeros(1, num_symbols); % Preasignación
    
    for block_idx = 1:num_ofdm_blocks
        % Extraer bloque sin CP
        start_idx = (block_idx-1)*(N_sub + cp_len) + cp_len + 1;
        rx_block = noisy_signal(start_idx:start_idx+N_sub-1);
        
        % Transformada directa
        fft_result = fft(rx_block, N_sub);
        
        % Extraer símbolos válidos
        rx_symbols((block_idx-1)*N_sub+1:min(block_idx*N_sub, num_symbols)) = ...
            fft_result(1:min(N_sub, num_symbols-(block_idx-1)*N_sub));
    end
    
    % Demodulación QPSK
    rx_bits = zeros(1, length(bit_stream));
    rx_bits(1:2:end) = real(rx_symbols) < 0;  % Bits I
    rx_bits(2:2:end) = imag(rx_symbols) < 0;  % Bits Q
    
    % Calcular BER
    bit_errors = sum(rx_bits ~= bit_stream);
    ber_results(idx) = bit_errors/length(bit_stream);
end

% Visualización de resultados 
figure('Position', [100 100 900 700]);

% PSD
subplot(3,1,1);
plot(freq/1e3, psd_db);
title(['Espectro de Potencia (', num2str(N_sub), ' subportadoras)']);
xlabel('Frecuencia (kHz)'); ylabel('Potencia (dB/Hz)');
grid on;

% PAPR
subplot(3,1,2);
plot(10*log10(instant_power/max(instant_power)), 'LineWidth', 1);
title(['PAPR = ', num2str(papr,2), ' dB']);
xlabel('Muestras'); ylabel('Potencia Normalizada (dB)');
grid on;
ylim([-30 0]);

% BER
subplot(3,1,3);
semilogy(ebno_range, ber_results, 'bo-', 'LineWidth', 2);
hold on;
semilogy(ebno_range, berawgn(ebno_range,'psk',4,'nondiff'), 'r--');
title('Desempeño BER');
xlabel('Eb/No (dB)'); ylabel('Bit Error Rate');
legend('Simulación', 'Teórico', 'Location', 'southwest');
grid on;

% Guardar resultados 
save('ofdm_results.mat', 'ofdm_signal', 'psd', 'papr', 'ber_results');
disp('Simulación OFDM completada exitosamente.');